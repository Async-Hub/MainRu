<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2020-04-14T20:52:18+04:00</updated><id>/feed.xml</id><title type="html">Программирование, облако и распределённые системы</title><subtitle>Разработка приложений на платформе Microsoft .NET Framework и не только.</subtitle><author><name>AsyncHub</name></author><entry><title type="html">Платформа ASP.NET Core 1.0. Часть 2: ASP.NET сегодня или что же выбрать?</title><link href="/2016/08/28/aspnet-core-1-0-part-2.html" rel="alternate" type="text/html" title="Платформа ASP.NET Core 1.0. Часть 2: ASP.NET сегодня или что же выбрать?" /><published>2016-08-28T21:07:22+04:00</published><updated>2016-08-28T21:07:22+04:00</updated><id>/2016/08/28/aspnet-core-1-0-part-2</id><content type="html" xml:base="/2016/08/28/aspnet-core-1-0-part-2.html">&lt;p&gt;Многие, в том числе и я, достаточно долго ждали выхода финальной версии .NET Core и ASP.NET Core и конечно дождались. Всего пару месяцев назад была выпущена RTM версия технологии для разработки веб приложений, получившая название ASP.NET Core 1.0. Напомню, что  ещё в начале текущего года именовалась она как ASP.NET 5. Продалжая данный цикл статей,  в детали темы. Всё самое новое, то, что сегодня может предоставить новейшая версии платформы Microsoft .NET, в общих чертах, было уже описано. Что ещё мы получим используя последнюю версию платформы .NET, а также более развёрнутое описание технологий веб-разработки, которые предлагает нам Microsoft сегодня будет дано далее и в последующих статьях. Достаточно открыть Visual Studio 2015 Update 3 с последней на данный момент версией Microsoft ASP.NET and Web Tools (VS2015Tools.Preview2.0.1), чтобы увидеть всё, что доступно нам уже сегодня.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-28-aspnet-core-1-0-part-2/A74I1.png&quot; alt=&quot;Image 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Из вышеприведённого изображения видно, что существует целых две категории шаблонов для ASP.NET приложений, для новейшей версии ASP.NET Core 1.0 и обновлённой – ASP.NET 4.5.1, которая официально получила номер ASP.NET 4.6. Насчёт последней цифры в версии было много споров, выбор был между номерами 4.5.3 и 4.6, в конце, на основе мнений большинства, остановились на последней. Разработчик, имеющий опыт работы с предыдущими версиями платформы наверняка в первую очередь продумает, что данный шаблон сделан для совместимости и для сопровождения предыдущих версий технологии. По крайней мере так было всегда, вспомним Visual Studio 2010/2012/2013. Так ли это? Отчасти, да. Но, с большими оговорками: помните рисунок из предыдущей статьи? Если оставить только содержимое для веба, то получи примерно следующее:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-28-aspnet-core-1-0-part-2/A74I2.png&quot; alt=&quot;Image2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Получается, что существует целых две актуальных технологии для разработки веб-приложений сегодня: ASP.NET 4.6 и ASP.NET Core 1.0, которые нам предлагает Microsoft. Детальное описание новейшей версии – ASP.NET Core будет дано в последующих статьях, в данной сравним обе  друг с другом. Для начала посмотрим что нам может предложить обновлённая версия ASP.NET 4.5.1? Давайте переместимся немного назад, а именно в год 2013-ый, когда состоялся релиз Visual Studio 2013. Если кто помнит, тогда мы не получили ничего абсолютно нового в плане глобальных изменений. Да, была реализована так называемая идея объединения технологий Web Forms, MVC и Web API, получившая официальное название «&lt;a href=&quot;https://msdn.microsoft.com/ru-ru/magazine/dn198242.aspx&quot;&gt;Единый ASP.NET&lt;/a&gt;» (“&lt;a href=&quot;https://channel9.msdn.com/Events/Visual-Studio/Launch-2013/WC103&quot;&gt;One ASP.NET&lt;/a&gt;”), но она &lt;a href=&quot;http://www.msdr.ru/44/&quot;&gt;немножко припозднилась&lt;/a&gt;, точнее могли раньше сделать, ничего этому не мешало, но не делали. Конечно, технологии и библиотеки были обновлены, но в глобальном плане ничего революционного не было, за исключением новой идеи – «OWIN» и её реализации «Katana». Для получения большей информации насчёт последних рекомендую ознакомиться с циклом статей «&lt;a href=&quot;/2014/12/23/microsoft-owin-and-aspnet-pipline-part-1.html&quot;&gt;Microsoft OWIN и конвейер обработки запросов ASP.NET&lt;/a&gt;». А что по сути дал нам OWIN в ASP.NET 4.5.1, ровным счётом ничего полезного. Единственное – конвейер усложнился ещё больше, хотя и без того был сложным. А сложность не является оправданной, если не приносит никакой пользы. В нижнем рисунке видна схема конвейеров, поставленная рядышком: слева – обычный конвейер ASP.NET/IIS, посередине тот же конвейер, но уже по спецификации OWIN, по сути их там два и правый – конвейер без IIS и ASP.NET.В частности можно увидеть насколько конвейер OWIN без IIS простой и легковесный (файл рисунка в более высоком разрешении можно &lt;a href=&quot;/assets/posts/2016-08-28-aspnet-core-1-0-part-2/A74I3H.png&quot;&gt;взять отсюда&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-28-aspnet-core-1-0-part-2/A74I3.jpg&quot; alt=&quot;Image3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Но почему спецификация OWIN была бесполезной и не принесла ничего нового и существенного. Просто её реализация тогда ещё была далека от совершенства, это же было началом конца монополии IIS для ASP.NET (&lt;a href=&quot;http://www.msdr.ru/57/&quot;&gt;Нужны ли нам ASP.NET и IIS?&lt;/a&gt;). Применение данной спецификации на IIS, как уже отметил выше не было полезным, а использование вне – затруднительным. Почему затруднительным? Да, потому, что насколько хорошей бы не была идея, её ещё нужно реализовать и «обкатить» как следует. Конечно, появилась возможность хостинга приложения вне IIS, но использовать свой сервер или хост (Self-Host) уровня обычного консольного приложения попросту неразумно для серьёзных приложений. Может мы чем-то не довольны в IIS, но все те средства администрирования (управление, диагностика, логирование и т.п.) сервера, весь тот опыт (багаж знаний) который есть уже, с этим нельзя не считаться. Всё же, именно &lt;a href=&quot;http://www.msdr.ru/62/&quot;&gt;дальнейшее развитие&lt;/a&gt; спецификации OWIN легло в основу ASP.NET Core. Несмотря на всё это ASP.NET 4.5.1 была обновлена и получила новую версию – ASP.NET 4.6. Следует отметить, что под ASP.NET 4.6 подразумевается весь следующий спектр технологий: Web Forms, MVC 5.x, Web API 2.x и SignalR 2.x. И на этот раз Microsoft не прекратила поддержку уже «устаревшей» технологии, а наоборот добавила очень много всего интересного и полезного. Ниже перечислен список самых важных нововведений.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Поддержка протокола HTTP/2.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Новая версия протокола HTTP добавлена в ASP.NET и в .NET Framework 4.6. Для использования HTTP/2 с ASP.NET приложение должно выполняться в Windows 10 или Windows Server 2016, важен не номер ОС, а версия IIS нужен IIS 10 или выше. Важно отметить, что пока ещё, на момент написания статьи, поддержка HTTP/2 не добавлена в ASP.NET Core, в будущем появится обязательно. HTTP/2 — это новая версия протокола HTTP, которая обеспечивает более эффективную коммуникацию (меньшее число циклов передачи-подтверждения между клиентом и сервером) и уменьшение задержки при загрузке веб-страницы для пользователей. HTTP/2 обеспечивает максимальное преимущество для веб-страниц (по сравнению со службами), так как оптимизирует запрос различных артефактов в ходе одной операции. Всю работу выполняют браузер и веб-сервер (IIS в Windows). Нет необходимости перекладывать нагрузку на пользователей. Большинство основных браузеров (новые версии) поддерживают HTTP/2, поэтому вполне вероятно, что пользователи смогут воспользоваться преимуществами протокола HTTP/2, если его поддерживает сервер. Более подробно о новом протоколе, к примеру, можно узнать по &lt;a href=&quot;https://channel9.msdn.com/events/Build/2015/3-88&quot;&gt;этой ссылке&lt;/a&gt; на Channel 9. На мой взгляд это очень существенное обновление для ASP.NET 4.6.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Добавлена поддержка .NET Compiler Platform (“Roslyn”) в ASP.NET.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;По мне, ещё одно существенное улучшение. Чтобы не быть многословным, отмечу самое ванное преимущество, которое мы получаем, используя Roslyn это – скорость компиляции. Вдобавок ко всему и новые возможности языков программирования, хотя я их считаю пока ещё мало полезными. Для получения больших сведений на данный счёт можете взглянуть, например, &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/webdev/enabling-the-net-compiler-platform-roslyn-in-asp-net-applications&quot;&gt;сюда&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Прочие улучшения и обновления в ASP.NET 4.6.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Далее перечислен список менее значимых, хотя вполне себе полезных улучшений и обновлений. Были обновлены MVC 5 и Web API 2 до версии 5.2.3, сделаны мелкие улучшения и исправления ошибок. Добавлена асинхронная модель привязки в Web Forms, были обновлены элементы управления для поддержки Entity Framework 6 и обновлена библиотека Ajax Control Toolkit. Полный перечень всего вышесказанного можно найти в &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/webdev/updates-for-asp-net-4-6-web-forms-mvc-5-web-api-2&quot;&gt;данной статье&lt;/a&gt;. Также следует отметить ещё одно улучшение, не относящееся непосредственно к платформе ASP.NET 4.6, но используемое ею, это – новый 64-разрядный JIT компилятора. В .NET Framework 4.6 представлена новая версия компилятора JIT, который имеет значительно большую производительность, чем существующий 64-разрядный компилятор JIT. Из всего вышеперечисленного видно, что изменений и улучшений не мало, что делает платформу ASP.NET 4.6 вполне себе актуальной на сегодняшний день. И конечно, улучения будут и в будущем.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;А что насчёт новейшей версии – ASP.NET Core?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Кратко перечислю основные значимые особенности, которые более детально будут описаны в последующих статьях. Намного более быстрая и легковесная среда выполнения. Возможность хостинга приложений где и как вам удобно, больше нет жёсткой привязки к IIS, хотя данная возможность появилась &lt;a href=&quot;http://www.msdr.ru/57/&quot;&gt;немного раньше&lt;/a&gt;, но была не совсем удобной и доработанной, как уже отметил выше. Полная модульность благодаря ключевым изменениям и .NET Core. Кроссплатформенность (возможность хостинга приложений вне Windows, а в данном случае это Linux и Mac OS), как бы широко не рекламировалась, лично по мне это не ключевое изменение, хотя могу ошибаться. Трудно представить разработчика, использующего всё, и вся от Microsoft переходящего с ASP.NET на другую ОС. Хотя вполне реально, что разработчики использующие другие платформы будут использовать ASP.NET Core вне Windows. Конечно есть альтернативные и не мене достойные веб-технологии и там. Далее, возможность конфигурирования и развёртывания намного упрощена, но разработчику долгое время работавшему с XML трудно и непривычно переходить на JSON. Хотя JavaScript библиотеки и платформы уже вовсю используют подход на основе JSON и поэтому иметь подобное на серверной стороне всё же намного удобней. Иметь единый стек как для интерфейса пользователя (Web UI), так и для API намного разумней, нежели два. Правда, на мой взгляд, задача была тогда отвязать и сделать отдельную технологию для создания служб HTTP, которую можно было бы развивать отдельно от ASP.NET/IIS, но это как видно не очень-то получилось. Также были добавлены новые средства, которые упрощают процесс диагностики приложения (об этом будет отдельная статья). Всё перечисленное выше делает приложения на ASP.NET Core более «дружественным к облаку» (Cloud Optimized ASP.NET), а как известно облачные технологии уже сегодня имеют большую роль и будут иметь ещё большую в будущем. И наконец отмечу, что все перечисленные изменения появились благодаря тому, что платформа была переписана почти с нуля, благодаря уже имеющемуся опыту и сегодняшним требованиям, а это уже о многом говорит.&lt;/p&gt;

&lt;p&gt;Название моей прошлогодней статьи &lt;a href=&quot;http://www.msdr.ru/62/&quot;&gt;«Microsoft ASP.NET vNext: эволюция или революция?»&lt;/a&gt; звучит слишком громко, но это вполне оправдано, если смотреть с точки зрения проделанной работы (которая на мой взгляд могла быть сделана и намного раньше), т.е. разницы с предыдущей. Да всё хорошо и замечательно, у нас много всего нового, но что нам, всем тем, кто использует данную платформу, даст новейшая технология? Ведь опыт показывает, что для построения «правильных» приложений технология уходит на второй план и в большинстве случаем не играет ключевую роль. То есть, если разработанное приложение не решает или решает плохо поставленные задачи, тогда никакая супер-мега технология, в подавляющем большинстве случаев, легко и просто не поможет кардинально исправить ситуацию. Если лет пять назад на так называемых «front-end» (замечу что под данным термином в данном случае я подразумеваю не верстальщика, а разработчика, уверенно владеющего JavaScript и разного рода библиотеками и технологиями на JavaScript) разработчиков смотрели косо, то ситуация сегодня совсем другая. Разрабатывать на JavaScript ничуть не легче и проще, а порой и ещё сложнее. JavaScript– это «душа» веба сегодня, нельзя с этим не считаться. Хотим мы того или нет, но подход, при котором HTML генерировался на сервере с помощью серверных технологий всё больше становится менее популярным, и это неизбежно и тому есть причина. Веб-приложение сегодня – это нечто намного и намного большее, чем было скажем лет десять назад. В свою очередь это влечёт за собой сложность, которая становится неоправданно высокой, если использовать серверные технологии, такие как ASP.NET Web Form или ASP.NET MVC для реализации логики работы сложного и интерактивного приложения на клиенте, вместо того же JavaScript. До сегодняшнего дня Visual Studio ничего близкого не могла предложить по сравнению, например, с тем же WebStorm (разработчики у кого есть опыт работы с WebStorm меня поймут) с точки зрения «front-end» разработки. А использовать приложение ASP.NET исключительно как сервисный слой не всегда разумно, учитывая альтернативные технологии. С приходом ASP.NET Core ситуации меняется, жаль, что не раньше, хотя функционал по работе с SPA и не только, по сравнению с WebStorm, на мой взгляд, пока ещё ограничен. Да, может я слишком критичен в последних приложениях, можно было бы обойтись существующими возможностями Visual Studio, но это жутко неудобно. К примеру, если взять тот же Gulp или Grunt, до Visual Studio 2015 и ASP.NET Core встроенных средств для работы с ними не было. Поэтому не может не радовать факт наличия много всего нового в ASP.NET Core. И так, будем прагматичны, имея две технологии для веб-разработки неизбежно возникнет вопрос:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Что нам следует сделать, каков наш выбор?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Выбор в данном случае не простой. Если у вас классическое приложение ASP.NET Web Forms и много свободных ресурсов (денег) – мигрируйте на ASP.NET Core. В случае ограниченных ресурсов, советую вам проделать постепенную миграцию до ASP.NET 4.6. Используя идею «Единый ASP.NET» это можно сделать поэтапно, где-то оставить старый код, где-то MVC, а в частях где производительность критична на клиенте и сервере тоже – подход с одностраничным приложением (SPA), например, используя AngularJS. Я со своими разработчиками делал подобное, есть опыт миграции корпоративных веб-порталов с ASP.NET 3.5 на ASP.NET 4.6. И скажу вам, что это не так просто, как вначале казалось, слишком много подводных камней (&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/yatajga/asp-net-3-5-asp-net-4-5-10&quot;&gt;вот один из многих&lt;/a&gt;) было, отчасти зависящих также и от качества кода. Ну а если ваш код не удовлетворяет вашим потребностям, то тут стоит задуматься именно над этим, а не о технологии или платформе. В том случае, если у вас приложение ASP.NET MVC, переходить на ASP.NET Core стоит в двух случаях: у вашего приложения проблемы с производительностью (вы сделали всё, дальше ничего оптимизировать невозможно) или у вас много денег свободного времени. В противном случае нужно улучшать свой код. Бывают случаи, когда код сильно завязан на System.Web.dll и IIS, это тоже весомый повод ничего не трогать. Ну и последний случай, если ASP.NET используется исключительно в виде веб-сервисов, например, в случае с Web API. Примером тому могут быть одностраничные приложения (SPA) или распределённые, которые могут и не иметь отношения к HTML. В подобном случае перейти на новую версию будет намного легче, чем в предыдущих. Опять-таки, если вас всё устраивает, то переходить на ASP.NET Core незачем. Почти во всех случаях, достаточно легко и быстро обновить .NET Framework до версии 4.6 и жить спокойно. Я знаю приложения и людей, которые используют всё ещё классический ASP и пока ещё их это устраивает. Если вы не довольны производительностью Web API и IIS, то это тоже повод для обновления на ASP.NET Core.&lt;/p&gt;

&lt;p&gt;Теперь осталось попытаться дать однозначный ответ на главный вопрос, так каков же наш выбор: ASP.NET 4.x или ASP.NET Core? Однозначного ответа нет, зависит от… И выбор за вами, однако, нужно помнить, что будущее за ASP.NET Core и рано или поздно оно наступит.&lt;/p&gt;</content><author><name>AsyncHub</name></author><summary type="html">Многие, в том числе и я, достаточно долго ждали выхода финальной версии .NET Core и ASP.NET Core и конечно дождались. Всего пару месяцев назад была выпущена RTM версия технологии для разработки веб приложений, получившая название ASP.NET Core 1.0. Напомню, что ещё в начале текущего года именовалась она как ASP.NET 5. Продалжая данный цикл статей, в детали темы. Всё самое новое, то, что сегодня может предоставить новейшая версии платформы Microsoft .NET, в общих чертах, было уже описано. Что ещё мы получим используя последнюю версию платформы .NET, а также более развёрнутое описание технологий веб-разработки, которые предлагает нам Microsoft сегодня будет дано далее и в последующих статьях. Достаточно открыть Visual Studio 2015 Update 3 с последней на данный момент версией Microsoft ASP.NET and Web Tools (VS2015Tools.Preview2.0.1), чтобы увидеть всё, что доступно нам уже сегодня.</summary></entry><entry><title type="html">Платформа ASP.NET Core 1.0. Часть 1: введение, общее описание и будущее .NET Framework</title><link href="/2016/08/15/aspnet-core-1-0-part-1.html" rel="alternate" type="text/html" title="Платформа ASP.NET Core 1.0. Часть 1: введение, общее описание и будущее .NET Framework" /><published>2016-08-15T21:07:22+04:00</published><updated>2016-08-15T21:07:22+04:00</updated><id>/2016/08/15/aspnet-core-1-0-part-1</id><content type="html" xml:base="/2016/08/15/aspnet-core-1-0-part-1.html">&lt;p&gt;На вопрос: «Microsoft ASP.NET vNext: эволюция или революция?» &lt;a href=&quot;http://www.msdr.ru/62/&quot;&gt;был дан однозначный ответ&lt;/a&gt; – революция. В данном цикле статей я постараюсь максимально подробно описать новейшую технологию для создания веб-приложений, а именно – ASP.NET vNext, которая в начале получила официальное название ASP.NET 5, а позднее была переименована в ASP.NET Core 1.0. Будет ещё один цикл, уже касающийся разработки реального приложения с примерами, посвящённый применению данной технологии на практике. Начну с описания истории развития ASP.NET. В далёком 1996 году компанией Microsoft была предложена технология – Active Server Pages (ASP) для создания Web-приложений. Принцип работы приложения ASP был примерно такой: веб-страница на сервере содержала серверные скрипты на VBScript или JScript и при запросе страницы происходил запуск и выполнение кода скриптов с последующей генерацией HTML. По сравнию с CGI это был большой шаг вперед. С выходом платформы Microsoft .NET Framework в 2002 году вышла совершенно новая платформа для разработки веб-приложений ASP.NET, которая была обновлена в 2003 году до версии ASP.NET 1.1. Именно тогда началась история ASP.NET. Это была совершенно новая, тогда ещё технология у которой было масса преимуществ перед ASP. По сути это был уже полноценный фреймворк для разработки веб-приложений. Время не стояло на месте, параллельно с развитием .NET Framework развивался и ASP.NET, в 2005 году было выпущено крупное обновление. Основными нововведениями были: темы, мастер-страницы, глобализация и т.п. Веб развивался быстрыми темпами, веб-страницы становились всё более интерактивными и насыщенными, появилась технология AJAX. В 2007 году было выпущено ещё одно крупное обновление – ASP.NET 3.5. Именно тогда появилась поддержка таких мощных средств как: ASP.NET AJAX, LINQ, Dynamic Data. С выпуском ASP.NET 3.5 SP1 в 2009 году был добавлен новый подход для обработки запросов веб-страниц на основе шаблона MVC. Теперь их стало целых два: Web Forms и MVC.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I1.png&quot; alt=&quot;Image 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Одновременно с запуском .NET Framework 4 была обновлена и ASP.NET до четвёртой версии. Ещё одно крупное обновление платформы было выпущено с выходом ASP.NET 4.5. Появились такие средства как Web API и SignalR. С выходом &lt;a href=&quot;http://www.msdr.ru/44/&quot;&gt;Visual Studio 2013&lt;/a&gt; появилась новая концепция – «Единый ASP.NET». Были обновлены все компоненты платформы, а также появилась новая спецификация &lt;a href=&quot;http://www.msdr.ru/52/&quot;&gt;OWIN – открытый интерфейс веб-сервера для .NET&lt;/a&gt; (Open Web Server Interface for .NET), которая стала основой ASP.NET vNext. А уже в прошлом году была выпущена предварительная версия кардинально переработанной технологии для разработки веб-приложений от Microsoft, которая получила официальное название – ASP.NET 5. Помимо прочего, также доступно очень большое количество обновленных и новых технологий и продуктов от Microsoft, финальные версии которых выйдут уже в этом году. А теперь обо всём этом по порядку. Начну с самого крупного и значимого события – обновления и улучшения .NET Framework. Прежде чем начать, вспомним историю развития .NET Framework:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I2.png&quot; alt=&quot;Image 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Платформа .NET была представлена в 2002 году и очень быстро завоевала популярность, став одной из основных современных средств разработки программного обеспечения. Её основными преумуществами перед предшественницей – технологией COM, которую она заменила, являются гибкость, более простая и надёжная модель программирования. Платформа равивалась, выходили всё новые версиии, библиотеки и технологии, для удовлетворения всё новых потребностей бысто развивающегося мира информационных технологий. Ну и конечно, Microsoft не сидит сложа руки, для того, чтобы идти в ногу со временем, продолжает улучшать платформу .NET. Совсем недавно платформа, представленная в прошлом году, была обновлена до версии .NET Framework 4.6.2. И так,  какое же будущее ожидает .NET? А будущее действительно очень интересное и многообещающее.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I3.png&quot; alt=&quot;Image 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Как видно из рисунка показанного выше, есть по сути две версии .NET Framework. Первая является логическим продолжением существующей версии .NET 4.5.2, которая получила официальное название – .NET 4.6 (обновлённые версии: .NET Framework 4.6.1 – 4.6.2). Вторая именуется теперь уже как .NET Core 1.0 (до этого известная как .NET Core 5) и является упрощённой версией обычного .NET Framework. Если с первым всё предельно ясно и понятно, то в случае со вторым возникает много вопросов. Самый главный – зачем он нам? Для удовлетворения быстрорастущих потребностей современного цифрового мира, который развивается стремительными темпами. Если взглянуть на шкалу развития платформы .NET приведённую выше, то можно увидеть, что цикл выпуска новых версий платформы составляет примерно пару лет, а то и больше, что является очень большим сроком при нынешнем положении дел. Нужно как то исправить ситуацию,  решение – .NET Core 1.0. Последний должен удовлетворять современным требованиям разработки, для этого были установлены новые тентенции для продвижения и развития платформы: быстрый цикл разработки и участие сообщества. Для этих целей специально была создана независимая организация ­&lt;a href=&quot;http://www.dotnetfoundation.org/&quot;&gt;.NET Foundation­&lt;/a&gt;, которая будет заниматься развитием экосистемы .NET. По &lt;a href=&quot;http://www.dotnetfoundation.org/projects&quot;&gt;данной ссылке&lt;/a&gt; перечислены все текущие проекты, которые будут развиваться под руководством последней. То есть получается платформа .NET становится открытой. Полная модульность – вот одна из главнейших возможностей, которая мне нравится больше всех. Особенно это полезно для веб-приложений, позже напишу почему.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I5.png&quot; alt=&quot;Image 4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Следующий рисунок показывает общую модель приложения, которая будет использовать платформу .NET Core. Модульность .NET Core означает, что фреймворк будет поставляться по частям через NuGet, тогда можно будет вместе с приложением поставлять саму платформу, которая будет изолирована от остальных. Т.е. не будет одной общей версии .NET на всю машину.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I6.png&quot; alt=&quot;Image 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Больше сведений про .NET 2015 и .NET Core можно узнать на &lt;a href=&quot;https://channel9.msdn.com/Events/dotnetConf/2015&quot;&gt;Channel 9&lt;/a&gt;. Также советую почитать &lt;a href=&quot;http://habrahabr.ru/company/microsoft/blog/245901/&quot;&gt;данную статью&lt;/a&gt; на хабре и &lt;a href=&quot;http://www.microsoftvirtualacademy.com/training-courses/the-development-of-modern-apps-in-c-sharp-rus&quot;&gt;изучить курс&lt;/a&gt; на сайте Microsoft Virtual Academy. А что нас ожидает в ближайшем будущем, каким будет .NET завтра?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I4.png&quot; alt=&quot;Image 6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Больше сведений относительно настоящего и будущего платформы можно узнать из докладов &lt;a href=&quot;https://channel9.msdn.com/events/dotnetConf/2016/NET-Conf-Day-1-Keynote-Scott-Hunter&quot;&gt;dotnetConf 2016&lt;/a&gt;. Теперь, поговорим об ASP.NET Core, ниже показана изображение общей схемы платформы.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2016-08-15-aspnet-core-1-0-part-1/A72I7.png&quot; alt=&quot;Image 7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Как можно видеть из рисунка, ключевыми свойствами новой технологии являются полная модульность и кроссплатформенность. То есть используя фреймворк как часть пакета развёртывания, больше не будет проблем конфигурации среды хостинга для приложения. Каждое приложение будет иметь свою, независимую версию платформы. Почти вся платформа написана с нуля и на управляемом коде, старого кода тут нет. Весь исходный код новейшей версии веб-платформы &lt;a href=&quot;https://github.com/aspnet&quot;&gt;открыт и доступен&lt;/a&gt; на GiHub. Технологии ASP.NET MVC и Web API объеденены в одну, а Web Forms больше не используется в версии ASP.NET Core. Новая версия ASP.NET в ОС Windows будет работать используя одну из двух версий .NET Framework: .NET 4.6 и .NET Core 1.0. На Linux и Mac OS X будет использоваться только .NET Core. Больше сведений по ASP.NET Core можно получить на &lt;a href=&quot;https://channel9.msdn.com/Series/Whats-New-with-ASPNET-5&quot;&gt;Channel 9 ­«What’s ­New with ASP.NET 5»&lt;/a&gt;­, тот же &lt;a href=&quot;http://www.microsoftvirtualacademy.com/training-courses/what-s-new-with-asp-net-5&quot;&gt;курс доступен на сайте&lt;/a&gt; Microsoft Virtual Academy (ASP.NET 5 была переименована в ASP.NET Core 1.0).­­ Также советую посмотреть курс &lt;a href=&quot;https://app.pluralsight.com/library/courses/aspdotnet-core-1-0-fundamentals/table-of-contents&quot;&gt;«ASP.NET Core 1.0 Fundamentals»&lt;/a&gt; от Pluralsight. Много очень интересного и полезного для себя я почерпнул из доклада &lt;a href=&quot;https://www.techdays.ru/videos/11181.html&quot;&gt;«ASP.NET vNext: What it means to you and what it means to Microsoft»&lt;/a&gt;, который я пересмотрел не раз. В следующей части будет рассморено всё то, что предлагает нам новейшая версия .NET Framework в плане веб-разработки.&lt;/p&gt;</content><author><name>AsyncHub</name></author><summary type="html">На вопрос: «Microsoft ASP.NET vNext: эволюция или революция?» был дан однозначный ответ – революция. В данном цикле статей я постараюсь максимально подробно описать новейшую технологию для создания веб-приложений, а именно – ASP.NET vNext, которая в начале получила официальное название ASP.NET 5, а позднее была переименована в ASP.NET Core 1.0. Будет ещё один цикл, уже касающийся разработки реального приложения с примерами, посвящённый применению данной технологии на практике. Начну с описания истории развития ASP.NET. В далёком 1996 году компанией Microsoft была предложена технология – Active Server Pages (ASP) для создания Web-приложений. Принцип работы приложения ASP был примерно такой: веб-страница на сервере содержала серверные скрипты на VBScript или JScript и при запросе страницы происходил запуск и выполнение кода скриптов с последующей генерацией HTML. По сравнию с CGI это был большой шаг вперед. С выходом платформы Microsoft .NET Framework в 2002 году вышла совершенно новая платформа для разработки веб-приложений ASP.NET, которая была обновлена в 2003 году до версии ASP.NET 1.1. Именно тогда началась история ASP.NET. Это была совершенно новая, тогда ещё технология у которой было масса преимуществ перед ASP. По сути это был уже полноценный фреймворк для разработки веб-приложений. Время не стояло на месте, параллельно с развитием .NET Framework развивался и ASP.NET, в 2005 году было выпущено крупное обновление. Основными нововведениями были: темы, мастер-страницы, глобализация и т.п. Веб развивался быстрыми темпами, веб-страницы становились всё более интерактивными и насыщенными, появилась технология AJAX. В 2007 году было выпущено ещё одно крупное обновление – ASP.NET 3.5. Именно тогда появилась поддержка таких мощных средств как: ASP.NET AJAX, LINQ, Dynamic Data. С выпуском ASP.NET 3.5 SP1 в 2009 году был добавлен новый подход для обработки запросов веб-страниц на основе шаблона MVC. Теперь их стало целых два: Web Forms и MVC.</summary></entry><entry><title type="html">Microsoft OWIN и конвейер обработки запросов ASP.NET. Часть первая, общее описание конвейера IIS и ASP.NET до появления спецификации OWIN.</title><link href="/2014/12/23/microsoft-owin-and-aspnet-pipline-part-1.html" rel="alternate" type="text/html" title="Microsoft OWIN и конвейер обработки запросов ASP.NET. Часть первая, общее описание конвейера IIS и ASP.NET до появления спецификации OWIN." /><published>2014-12-23T17:19:22+04:00</published><updated>2014-12-23T17:19:22+04:00</updated><id>/2014/12/23/microsoft-owin-and-aspnet-pipline-part-1</id><content type="html" xml:base="/2014/12/23/microsoft-owin-and-aspnet-pipline-part-1.html">&lt;p&gt;Достаточно давно я хотел написать цикл статей про конвейер обработки запросов IIS и ASP.NET, но по причине отсутствия свободного времени никак не получалось. Ограничился лишь &lt;a href=&quot;http://www.msdr.ru/9/&quot;&gt;данными статьями&lt;/a&gt;. И вот такая возможность появилась. C выходом Visual Studio 2013 появилось много новшеств в ASP.NET. В частности таких как: единый ASP.NET и спецификация OWIN. О том какие преимущества даёт нам первая, было коротко написано в &lt;a href=&quot;http://www.msdr.ru/44/&quot;&gt;данной статье&lt;/a&gt;. Ну а обо всём остальном я расскажу далее. В этой статье я покажу весь конвейер IIS и ASP.NET, чтобы в других частях статей (про Microsoft OWIN) можно было бы использовать данную схему.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-1/IIS-and-ASP.NET-piplinev1.0.jpg&quot; alt=&quot;IIS-and-ASP.NET-pipline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Когда я сам только начинал свой путь разработчика сильно нуждался в подобных наглядных схемах. Думаю, теперь это будет полезно другим. В следующих частях уже будет описана спецификация OWIN и всё что с этим связано в IIS и ASP.NET. &lt;a href=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-1/IIS and ASP.NET pipline.pdf&quot;&gt;Вот ссылка на pdf файл&lt;/a&gt; высокого качества.&lt;/p&gt;</content><author><name>AsyncHub</name></author><summary type="html">Достаточно давно я хотел написать цикл статей про конвейер обработки запросов IIS и ASP.NET, но по причине отсутствия свободного времени никак не получалось. Ограничился лишь данными статьями. И вот такая возможность появилась. C выходом Visual Studio 2013 появилось много новшеств в ASP.NET. В частности таких как: единый ASP.NET и спецификация OWIN. О том какие преимущества даёт нам первая, было коротко написано в данной статье. Ну а обо всём остальном я расскажу далее. В этой статье я покажу весь конвейер IIS и ASP.NET, чтобы в других частях статей (про Microsoft OWIN) можно было бы использовать данную схему.</summary></entry><entry><title type="html">Microsoft OWIN и конвейер обработки запросов ASP.NET. Часть вторая, спецификация OWIN и его реализация компанией Microsoft. Проект Katana, общее описание.</title><link href="/2014/12/23/microsoft-owin-and-aspnet-pipline-part-2.html" rel="alternate" type="text/html" title="Microsoft OWIN и конвейер обработки запросов ASP.NET. Часть вторая, спецификация OWIN и его реализация компанией Microsoft. Проект Katana, общее описание." /><published>2014-12-23T17:19:22+04:00</published><updated>2014-12-23T17:19:22+04:00</updated><id>/2014/12/23/microsoft-owin-and-aspnet-pipline-part-2</id><content type="html" xml:base="/2014/12/23/microsoft-owin-and-aspnet-pipline-part-2.html">&lt;p&gt;OWIN – открытый интерфейс веб-сервера для .NET (Open Web Server Interface for .NET). Или говоря по другому – это спецификация определяющая абстакцию посредством которой взаимодействуют веб-сервер и веб-приложение. Более подробное описание спецификации можно найти на сайте &lt;a href=&quot;http://owin.org&quot;&gt;owin.org&lt;/a&gt;, а если более конкретно, то &lt;a href=&quot;http://http://owin.org/spec/spec/owin-1.0.0.html&quot;&gt;тут&lt;/a&gt;. Чтобы легче было себе представить, нужно взглянуть на рисунок приведённый ниже.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/2376.A50I1.jpg&quot; alt=&quot;Image 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Правая диаграмма показывает общую схему структуры приложения, которое использует спецификацию OWIN для организации взаимодействия между компонентами всей инфраструктуры. Левая – схему структуры веб-приложений в Windows без использования этой спецификации, то есть то, что было раньше (есть и сейчас и будет в будущем). Если применить спецификацию OWIN  к связке IIS/ASP.NET, то получится примерно следующее.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/5367.A50I2.jpg&quot; alt=&quot;Image 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Замечу сразу, что если быть более точным, то ни правая диаграмма первого рисунка и ни данная, в абсолютной точности не выражают схему организации структуры. Все дело в том, что нельзя просто так взять и отделить части схемы на независимые куски. Просто, на мой взгляд, для быстрого восприятия материала, они являются наиболее оптимальными для иллюстрации общей картины. Ну а дальше всё постепенно прояснится. Вернувшись к теме сразу возникает вопрос: а зачем лишний уровень абстракции и в без того &lt;a href=&quot;/2014-12-23-microsoft-owin-and-aspnet-pipline-part-1&quot;&gt;перегруженный конвейер&lt;/a&gt; IIS/ASP.NET ? Отвечу коротко – почти незачем, просто это одна из реализаций организации работы приложения по спецификации OWIN с использованием IIS/ASP.NET. Остальные выводы будут сделаны в конце статьи. В самом начале статьи упоминалось о взаимодействии сервера и приложения, на практике, такое взаимодействие сводится к использованию функций с сигнатурой одного единственного делегата, так называемого &lt;strong&gt;&lt;em&gt;делегата приложения&lt;/em&gt;&lt;/strong&gt;. Который имеет следующий вид:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;AppFunc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Входной параметр имеющий тип &lt;strong&gt;IDictionary&amp;lt;string, object&amp;gt;&lt;/strong&gt; и называемый – &lt;em&gt;словарь окружения&lt;/em&gt;, содержит все данные (переменные сервера, данные запроса и т.п.). Он не может иметь значение &lt;strong&gt;null&lt;/strong&gt;, а так же быть пустым. Кроме того, должен содержать &lt;a href=&quot;http://owin.org/spec/spec/owin-1.0.0.html#_3.2._Environment&quot;&gt;некоторые ключи&lt;/a&gt; определённые спецификацией. Выходной параметр имеет тип &lt;strong&gt;Task&lt;/strong&gt; – инкапсулирует некоторую выполняемую задачу. На основе данного делегата строятся компонеты приложения и объединяются в цепочку, тем самым формируется конвейер обработки запросов OWIN, куда передаётся запрос на обработку. Из типа возвращаемого делегатом уже видно, что он будет работать в асинхронном режиме. Пока, всё описанное выше – это только теория. Microsft OWIN или проект под названием &lt;strong&gt;Katana&lt;/strong&gt; является реализацией спецификации OWIN компанией Microsoft. Исходный код проекта полность открытый и находится на CodePlex по &lt;a href=&quot;https://katanaproject.codeplex.com/&quot;&gt;следующему адресу&lt;/a&gt;. На момент написания статьи текущая версия 3.0.0 Alpha, а RTM версия – 2.1.0. Именно последняя будет описана и использоваться в дальнейшем. Ниже представлена визуальная схема архитектуры проекта Katana, &lt;a href=&quot;http://owin.org/spec/spec/owin-1.0.0.html&quot;&gt;согласно спецификации&lt;/a&gt; OWIN.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/2626.A50I3.jpg&quot; alt=&quot;Image 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Если скачать и открыть проект, то можно увидеть, что примерно так всё и выглядит.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/1452.A50I4.jpg&quot; alt=&quot;Image 4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ниже представлены схематические изображения архитектуры веб-приложений использующих Katana и работающих по спецификации OWIN.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/2248.A50I5.jpg&quot; alt=&quot;Image 5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;И так, что же означает абреввиатура OWIN показанная на диаграммах как промежуточный слой. Это основное связующее звено в приложении, того самого промежуточного слоя, представленное в виде единственного интерфейса &lt;strong&gt;IAppBuilder&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Owin&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IAppBuilder&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;returnType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;IAppBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;IAppBuilder&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Use&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;middleware&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
        &lt;span class=&quot;n&quot;&gt;IDictionary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Properties&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Интерфейс не является частью спецификации. Тут есть очень тонкий момент: вся инфраструктура работает по спецификации OWIN, а данная абреввиатура на диаграммах, наглядно показывает просто конкретную реализацию промежуточного слоя. Теперь, чтобы лучше понять материал я покажу как создать очень простое веб-приложение, которое будет работать по спецификации OWIN. Для начала нам нужен хост, процесс в Windows в котором будет работать наше приложение. Для этого создадим простое консольное приложение в Visual Studio 2013.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/6886.A50I6.jpg&quot; alt=&quot;Image 6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Естественно, реализация спецификации OWIN задача ресурсоёмкая, поэтому и есть проект Katana. Воспользуемся некоторыми готовыми компонентами Katana, установив их через NuGet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/8540.A50I7.jpg&quot; alt=&quot;Image 7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Как видно из рисунка выше, было установлено четыре сборки. Сборка OWIN, содержит один едниственный интерфейс – IAppBuilder, который был описан выше. Microsoft.Owin – содержит множество вспомагательных типов, которые облегчают создание разных  компонетов Owin. Например: OwinRequest, OwinResponse, OwinContext и т.д. Сборка Microsoft.Owin.Hosting содержит типы необходимые для хостинга и запуска приложения. Ну а сборка Microsoft.Owin.Host.HttpListener содержит дефолтовый сервер OwinHttpListener проекта Katana. Это по сути обёртка вокруг стандартного System.Net.HttpListener. Для конфигурации приложения при запуске, Katana ищет класс Startup. В качестве шаблонного элемента он присутсвует в Visual Studio 2013. Добавим его. Более подробно об алгоритме поиска класса Startup написано &lt;a href=&quot;http://www.asp.net/aspnet/overview/owin-and-katana/owin-startup-class-detection&quot;&gt;тут&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/3750.A50I8.jpg&quot; alt=&quot;Image8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Осталось добавить код, запускающий сервер:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Microsoft.Owin.Hosting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;SimpleOwinApplication&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Program&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uri&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://localhost:8088/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
            &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WebApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uri&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Server started&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ReadKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Server stoped&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;и код конфигурации.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Owin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Microsoft.Owin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;assembly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OwinStartup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SimpleOwinApplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))]&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;SimpleOwinApplication&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Startup&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IAppBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ContentType&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;text/html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Response&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteAsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;htmlText&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
        &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;htmlText&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;html&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                          &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;head&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                              &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                          &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;/head&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                          &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;body&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                              &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;h1&amp;gt;Simple Owin Application&amp;lt;h1&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                          &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;/body&amp;gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                                        &lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;/html&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ничего особенного тут не происходит. Просто на все запросы к хосту, сервет отвечает куском кода HTML. В следующей части все детали конвейера OWIN и его компоненты будут расмотрены более детально.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/posts/2014-12-23-microsoft-owin-and-aspnet-pipline-part-2/4520.A50I9.jpg&quot; alt=&quot;Image9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Запускаем приложение, и видим что всё работает. Здесь находится &lt;a href=&quot;http://www.msdr.ru/files/SimpleOwinApplication.zip&quot;&gt;ссылка на проект&lt;/a&gt;. Тут уже назревает вопрос: зачем нам всё это, плохо ли было без этого? Конечно нет, но если посмотреть с другой стороны, то инфраструктура веб-приложения построенная по спецификации OWIN при помощи управляемого кода даёт нам полную свободу действий и гибкость, еcли мы реализуем её без использования существующей. То есть, если мы не используем IIS/ASP.NET. Лично я не вижу смысла использовать спецификацию OWIN в приложениях IIS/ASP.NET, об этом будет ещё написано в следующих статьях. Почему не стоит? Да потому, что конвейер IIS/ASP.NET и &lt;a href=&quot;/2014/12/23/microsoft-owin-and-aspnet-pipline-part-1.html&quot;&gt;без того перегружен&lt;/a&gt;. Незачем вводить ещё один дополнительный слой абстракции. И к тому же технология ASP.NET достаточно зрелая и используя накопленные возможности и опыт можно решить очень широкий круг задач, что мы и делали до сих пор и будем делать. Вывод – спецификация OWIN позволяет пересмотреть  архитектуру веб-инфраструктуры не принося ничего нового в уже существующую, но позволяющая построить совершенно новую и полностью управляемую архитектуру инфраструктуры.&lt;/p&gt;</content><author><name>AsyncHub</name></author><summary type="html">OWIN – открытый интерфейс веб-сервера для .NET (Open Web Server Interface for .NET). Или говоря по другому – это спецификация определяющая абстакцию посредством которой взаимодействуют веб-сервер и веб-приложение. Более подробное описание спецификации можно найти на сайте owin.org, а если более конкретно, то тут. Чтобы легче было себе представить, нужно взглянуть на рисунок приведённый ниже.</summary></entry></feed>